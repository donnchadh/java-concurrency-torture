<testsuite suite="primitiveAtomics">
    <test>
        <name>net.shipilev.concurrent.torture.negative.DoubleAtomicityTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive doubles experience non-atomic updates.
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the field. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[0, 0, 0, 0, -1, -1, -1, -1]</match>
            <match>[-1, -1, -1, -1, 0, 0, 0, 0]</match>
            <outcome>NEGATIVE_MISSING</outcome>
            <description>
                Seeing the torn value. This is specifically allowed by <![CDATA[<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">JLS 17.7</a>]]>.
                This is not a surprising behavior on some 32-bit systems which do not have full-width 64-bit instructions.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.IntAtomicityTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive integers experience non-atomic updates.
        </description>
        <case>
            <match>[0, 0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the field. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.LongAtomicityTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive longs experience non-atomic updates.
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the field. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[0, 0, 0, 0, -1, -1, -1, -1]</match>
            <match>[-1, -1, -1, -1, 0, 0, 0, 0]</match>
            <outcome>NEGATIVE_MISSING</outcome>
            <description>
                Seeing the torn value. This is specifically allowed by <![CDATA[<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">JLS 17.7</a>]]>.
                This is not a surprising behavior on some 32-bit systems which do not have full-width 64-bit instructions.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.VolatileLongAtomicityTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if volatile longs experience non-atomic updates.
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the field. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Seeing other values is forbidden by JMM.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.ReadTwiceTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if intervening writes break the ordering.
        </description>
        <case>
            <match>[0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the fields. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[0, 1, 0]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The evidence for the correct reordering: the later write is seen first.
            </description>
        </case>
        <case>
            <match>[1, 0, 1]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                Write to $y is still in flight, $x is already here.
            </description>
        </case>
        <case>
            <match>[0, 0, 1]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                Write to $y is still in flight, $x is arriving late.
                This is the evidence the compiler had not merged the loads for $x.
            </description>
        </case>
        <case>
            <match>[0, 1, 1]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The writes appear the the writers' order.
                This code also means the compiler had not merged the loads for $x.
            </description>
        </case>
        <case>
            <match>[1, 0, 0]</match>
            <match>[1, 1, 0]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                TODO: Odd, but legal case?
            </description>
        </case>
        <case>
            <match>[1, 1, 1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Both updates are visible.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.ReadAfterVolatileReadTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if volatile write-read induce proper happens-before.
        </description>
        <case>
            <match>[0, 0]</match>
            <match>[0, 1]</match>
            <match>[0, 2]</match>
            <match>[0, 3]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Volatile write to $y did not yet happened, the observer is allowed to see any value for $x.
            </description>
        </case>
        <case>
            <match>[1, 0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Can't read the default value for $x after $y is effective.
            </description>
        </case>
        <case>
            <match>[1, 1]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Can't read the stale value for $x after $y is effective.
            </description>
        </case>
        <case>
            <match>[1, 2]</match>
            <match>[1, 3]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                Can see either after volatile write to $y is in effect.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.ReadTwiceOverVolatileReadTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Test if volatile write-read induces happens-before if in between two non-volatile reads.
        </description>
        <case>
            <match>[0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the fields. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[0, 1, 0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Volatile write to $y had happened, and update to $x had been lost.
            </description>
        </case>
        <case>
            <match>[1, 1, 0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Volatile write to $y had happened, and update to $x had been lost (this one is very weird).
            </description>
        </case>
        <case>
            <match>[0, 0, 1]</match>
            <match>[1, 0, 1]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                Write to $y is still in flight, $x is arriving late.
                This is the evidence the compiler had not merged the loads for $x.
            </description>
        </case>
        <case>
            <match>[0, 1, 1]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The writes appear the the writers' order.
                This code also means the compiler had not merged the loads for $x.
            </description>
        </case>
        <case>
            <match>[1, 1, 1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Both updates are visible.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.AtomicIntegerIncrementTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests the atomicity of AtomicInteger incrementAndGet.
        </description>
        <case>
            <match>[2]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Required to see both updates.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Other cases are not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.VolatileAtomicityTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests the atomicity of volatile increment.
        </description>
        <case>
            <match>[0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Can not see the default value.
            </description>
        </case>
        <case>
            <match>[1]</match>
            <outcome>NEGATIVE_MISSING</outcome>
            <description>
                One update is lost.
            </description>
        </case>
        <case>
            <match>[2]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Seeing both updates.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Other cases are not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.RacyPublicationTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests the races during unsafe publication.
        </description>
        <case>
            <match>[1, 1, 1, 1, 1, 1, 1, 1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Seeing the object in fully-constructed way.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Observer sees null reference to the object.
                This is the correct case, since there is an intrinsic race between actor and observer.
            </description>
        </case>
        <unmatched>
            <outcome>NEGATIVE_MISSING</outcome>
            <description>
                This should be under-uninitialized case. This is a correct JMM behavior.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.UnsafeSingletonTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests the broken DCL-style singleton.
        </description>
        <case>
            <match>[0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Factory returned null singleton. This is the major correctness issue.
            </description>
        </case>
        <case>
            <match>[1]</match>
            <outcome>NEGATIVE_MISSING</outcome>
            <description>
                The reference field in singleton is null.
                This is the functional failure, but legal JMM behavior.
            </description>
        </case>
        <case>
            <match>[42]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The singleton is observed in fully-constructed way.
            </description>
        </case>
        <unmatched>
            <outcome>NEGATIVE_MISSING</outcome>
            <description>
                This should be under-uninitialized case. This is a correct JMM behavior.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.init.LongConstrTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive long fields are properly initialized (in constructor).
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                Seeing the default value for long field. The update to the field in the constructor is lost.
                This is a legal JMM behavior.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[42, 42, 42, 42, 42, 42, 42, 42]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The observer sees the empty shell.
                This is a legal JMM behavior, since there is a race between actor and observer.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.init.LongInstanceTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive long fields are properly initialized (by instance initializer).
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                Seeing the default value for long field. The update to the field in the constructor is lost.
                This is a legal JMM behavior.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[42, 42, 42, 42, 42, 42, 42, 42]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The observer sees the empty shell.
                This is a legal JMM behavior, since there is a race between actor and observer.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.init.LongFinalTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive long fields are properly initialized (final field set in constructor).
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Seeing the default value for long field. The update to the field in the constructor is lost.
                This is a legal JMM behavior.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[42, 42, 42, 42, 42, 42, 42, 42]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The observer sees the empty shell.
                This is a legal JMM behavior, since there is a race between actor and observer.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.positive.init.Long</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive long fields are properly initialized (volatile field set in constructor).
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                Seeing the default value for long field. The update to the field in the constructor is lost.
                This is a legal JMM behavior.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[42, 42, 42, 42, 42, 42, 42, 42]</match>
            <outcome>ACCEPTABLE</outcome>
            <description>
                The observer sees the empty shell.
                This is a legal JMM behavior, since there is a race between actor and observer.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_MISSING</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

</testsuite>