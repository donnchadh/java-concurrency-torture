<testsuite suite="primitiveAtomics">
    <test>
        <name>net.shipilev.concurrent.torture.negative.DoubleAtomicityTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive doubles experience non-atomic updates.
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the field. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[0, 0, 0, 0, -1, -1, -1, -1]</match>
            <match>[-1, -1, -1, -1, 0, 0, 0, 0]</match>
            <outcome>NEGATIVE_FAILURE</outcome>
            <description>
                Seeing the torn value. This is specifically allowed by JLS 17.7.
                This is not a surprising behavior on some 32-bit systems which do not have full-double instructions.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_FAILURE</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.LongAtomicityTest</name>
        <file>negative/DoubleAtomicityTest.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if primitive longs experience non-atomic updates.
        </description>
        <case>
            <match>[0, 0, 0, 0, 0, 0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the field. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[-1, -1, -1, -1, -1, -1, -1, -1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                The value set by the actor thread. Observer sees the complete update.
            </description>
        </case>
        <case>
            <match>[0, 0, 0, 0, -1, -1, -1, -1]</match>
            <match>[-1, -1, -1, -1, 0, 0, 0, 0]</match>
            <outcome>NEGATIVE_FAILURE</outcome>
            <description>
                Seeing the torn value. This is specifically allowed by JLS 17.7.
                This is not a surprising behavior on some 32-bit systems which do not have full-double instructions.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_FAILURE</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>

    <test>
        <name>net.shipilev.concurrent.torture.negative.ReadTwiceTest</name>
        <file>negative/ReadTwice.java</file>
        <contributed-by>Aleksey Shipilev (aleksey.shipilev@oracle.com)</contributed-by>
        <description>
            Tests if intervening writes break the ordering.
        </description>
        <case>
            <match>[0, 0, 0]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Default value for the fields. Observers are allowed to see the default value for the field,
                because there is the data race between reader and writer.
            </description>
        </case>
        <case>
            <match>[0, 1, 0]</match>
            <outcome>POSITIVE_ACCEPTABLE</outcome>
            <description>
                The evidence for the correct reordering: the later write is seen first.
            </description>
        </case>
        <case>
            <match>[1, 0, 1]</match>
            <outcome>POSITIVE_ACCEPTABLE</outcome>
            <description>
                Write to $y is still in flight, $x is already here.
            </description>
        </case>
        <case>
            <match>[0, 0, 1]</match>
            <outcome>POSITIVE_ACCEPTABLE</outcome>
            <description>
                Write to $y is still in flight, $x is arriving late.
                This is the evidence the compiler had not merged the loads for $x.
            </description>
        </case>
        <case>
            <match>[0, 1, 1]</match>
            <outcome>POSITIVE_ACCEPTABLE</outcome>
            <description>
                The writes appear the the writers' order.
                This code also means the compiler had not merged the loads for $x.
            </description>
        </case>
        <case>
            <match>[1, 0, 0]</match>
            <match>[1, 1, 0]</match>
            <outcome>POSITIVE_ACCEPTABLE</outcome>
            <description>
                TODO: Odd, but legal case?
            </description>
        </case>
        <case>
            <match>[1, 1, 1]</match>
            <outcome>POSITIVE_REQUIRED</outcome>
            <description>
                Both updates are visible.
            </description>
        </case>
        <unmatched>
            <outcome>POSITIVE_FAILURE</outcome>
            <description>
                This case is not expected.
            </description>
        </unmatched>
    </test>


</testsuite>